# GoF â€” 23 Design Patterns with Java examples

## ðŸ”¹ Dizayn Pattern nima?

**Design Pattern** â€“ bu dasturiy taâ€™minot ishlab chiqishda tez-tez uchraydigan muammolarga **tayyor yechim**.
Yaâ€™ni, bu kod emas, balki **qanday qilib kodni tashkil qilish kerakligi boâ€˜yicha qoida va shablonlar**.

> Gang of Four (GoF) â€“ Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides â€“ 1994-yilda **23 ta mashhur pattern**ni kitob qilib chiqargan.

---

## ðŸ”¹ Patternlarning asosiy turlari

Design patternlar 3 asosiy turga boâ€˜linadi:

### 1. **Creational (Yaratilish patternlari)**

Obyektlarni yaratishni boshqaradi.

* **Singleton** â€“ bitta obyekt yaratilishini taâ€™minlaydi. (masalan: Logger, Config)
* **Factory Method** â€“ obyekt yaratishni subclasslarga topshiradi.
* **Abstract Factory** â€“ bir-biriga bogâ€˜liq obyektlarni yaratadi.
* **Builder** â€“ murakkab obyektlarni bosqichma-bosqich yaratadi.
* **Prototype** â€“ mavjud obyektni clone qilib yangi obyekt yaratadi.

### 2. **Structural (Tuzilish patternlari)**

Obyektlar va klasslarni qanday ulashni belgilaydi.

* **Adapter** â€“ turlicha interfeyslarni moslashtiradi. (USB â†’ Type-C adapter kabi)
* **Decorator** â€“ obyekt funksiyasini runtimeâ€™da kengaytiradi.
* **Facade** â€“ murakkab tizim uchun soddalashtirilgan interfeys beradi.
* **Composite** â€“ obyektlarni daraxt koâ€˜rinishida ishlatadi.
* **Proxy** â€“ boshqa obyektga kirishni nazorat qiladi. (masalan: lazy loading)
* **Bridge** â€“ abstraktsiya va implementatsiyani ajratadi.
* **Flyweight** â€“ koâ€˜p obyektni xotirani tejash uchun qayta ishlatadi.

### 3. **Behavioral (Xatti-harakat patternlari)**

Obyektlar oâ€˜rtasidagi muloqot va masâ€™uliyatni belgilaydi.

* **Strategy** â€“ algoritmlarni tanlash imkonini beradi.
* **Observer** â€“ obyekt oâ€˜zgarishini kuzatuvchilarga xabar beradi. (masalan: event listener)
* **Command** â€“ amallarni obyekt sifatida ifodalaydi.
* **State** â€“ obyekt xatti-harakati holatga qarab oâ€˜zgaradi.
* **Template Method** â€“ algoritm skeletini belgilab, detallarga subclass javobgar.
* **Iterator** â€“ kolleksiya elementlarini ketma-ket oâ€˜qiydi.
* **Mediator** â€“ obyektlar oâ€˜rtasida muloqotni markazlashtiradi.
* **Memento** â€“ obyektning oldingi holatini saqlaydi va qaytaradi.
* **Chain of Responsibility** â€“ masâ€™uliyatni zanjir boâ€˜ylab uzatadi.
* **Interpreter** â€“ til yoki grammatikani ishlashini taâ€™minlaydi.
* **Visitor** â€“ obyektlar ustida qoâ€˜shimcha operatsiyalarni bajaradi.

---

## ðŸ”¹ Amaliy misollar

### âœ… Singleton (Java misolida):

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### âœ… Strategy

```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " with Credit Card");
    }
}

class PaypalPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("Paid " + amount + " with PayPal");
    }
}

// Client
class ShoppingCart {
    private PaymentStrategy strategy;
    public ShoppingCart(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    public void checkout(int amount) {
        strategy.pay(amount);
    }
}
```

---

## ðŸ”¹ Qachon ishlatamiz?

* **Singleton** â€“ konfiguratsiya, cache, logger.
* **Factory** â€“ turli obyektlarni yaratishda.
* **Observer** â€“ event-driven arxitekturada.
* **Facade** â€“ murakkab subsystemâ€™ni yashirishda.
* **Strategy** â€“ algoritmni runtimeâ€™da almashtirish kerak boâ€˜lsa.

---

## ðŸ”¹ Foydasi

* Kodni **takrorlanishidan saqlaydi**.
* **Oâ€˜qilishi va kengaytirilishi** oson boâ€˜ladi.
* Dasturiy taâ€™minot **mustahkam va moslashuvchan** boâ€˜ladi.

---


## Table of contents
1. Creational
   - Singleton
   - Factory Method
   - Abstract Factory
   - Builder
   - Prototype
2. Structural
   - Adapter
   - Bridge
   - Composite
   - Decorator
   - Facade
   - Flyweight
   - Proxy
3. Behavioral
   - Chain of Responsibility
   - Command
   - Interpreter
   - Iterator
   - Mediator
   - Memento
   - Observer
   - State
   - Strategy
   - Template Method
   - Visitor

---

## 1. Creational Patterns

### 1.1 Singleton
```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) instance = new Singleton();
            }
        }
        return instance;
    }
}
```

### 1.2 Factory Method
```java
// Product
interface Transport { void drive(); }
class Car implements Transport { public void drive(){ System.out.println("Car driving"); } }
class Bike implements Transport { public void drive(){ System.out.println("Bike riding"); } }

// Creator
abstract class Logistics {
    abstract Transport createTransport();
    void planDelivery(){ Transport t = createTransport(); t.drive(); }
}

class RoadLogistics extends Logistics { Transport createTransport(){ return new Car(); } }
class BikeLogistics extends Logistics { Transport createTransport(){ return new Bike(); } }
```

### 1.3 Abstract Factory
```java
// Abstract products
interface Button { void paint(); }
interface Checkbox { void paint(); }

// Concrete products
class WinButton implements Button { public void paint(){ System.out.println("Windows Button"); } }
class MacButton implements Button { public void paint(){ System.out.println("Mac Button"); } }
class WinCheckbox implements Checkbox { public void paint(){ System.out.println("Windows Checkbox"); } }
class MacCheckbox implements Checkbox { public void paint(){ System.out.println("Mac Checkbox"); } }

// Abstract factory
interface GUIFactory { Button createButton(); Checkbox createCheckbox(); }
class WinFactory implements GUIFactory { public Button createButton(){ return new WinButton(); } public Checkbox createCheckbox(){ return new WinCheckbox(); } }
class MacFactory implements GUIFactory { public Button createButton(){ return new MacButton(); } public Checkbox createCheckbox(){ return new MacCheckbox(); } }
```

### 1.4 Builder
```java
class Pizza {
    private final String dough; private final String sauce; private final String topping;
    private Pizza(Builder b){ dough=b.dough; sauce=b.sauce; topping=b.topping; }
    static class Builder{
        private String dough; private String sauce; private String topping;
        Builder dough(String d){ this.dough=d; return this; }
        Builder sauce(String s){ this.sauce=s; return this; }
        Builder topping(String t){ this.topping=t; return this; }
        Pizza build(){ return new Pizza(this); }
    }
}

// Usage: Pizza p = new Pizza.Builder().dough("thin").sauce("tomato").topping("cheese").build();
```

### 1.5 Prototype
```java
class Sheep implements Cloneable {
    private String name;
    public Sheep(String name){ this.name = name; }
    public Sheep clone() throws CloneNotSupportedException { return (Sheep) super.clone(); }
    public String toString(){ return "Sheep: " + name; }
}

// Usage:
// Sheep s1 = new Sheep("Dolly"); Sheep s2 = s1.clone();
```

---

## 2. Structural Patterns

### 2.1 Adapter
```java
// Adaptee
class XmlService { String getXml(){ return "<data/>"; } }
// Target
interface JsonService { String getJson(); }
// Adapter
class XmlToJsonAdapter implements JsonService {
    private XmlService xmlService;
    XmlToJsonAdapter(XmlService xmlService){ this.xmlService = xmlService; }
    public String getJson(){ String xml = xmlService.getXml(); return "{\"data\":null}"; /* transform xml->json */ }
}
```

### 2.2 Bridge
```java
// Implementor
interface Renderer { void renderCircle(int radius); }
class VectorRenderer implements Renderer { public void renderCircle(int r){ System.out.println("Vector circle " + r); } }
class RasterRenderer implements Renderer { public void renderCircle(int r){ System.out.println("Raster circle " + r); } }

// Abstraction
abstract class Shape {
    protected Renderer renderer;
    protected Shape(Renderer renderer){ this.renderer = renderer; }
    abstract void draw();
}
class Circle extends Shape {
    private int radius;
    Circle(Renderer renderer, int r){ super(renderer); this.radius = r; }
    void draw(){ renderer.renderCircle(radius); }
}
```

### 2.3 Composite
```java
import java.util.*;
interface Component { void render(); }
class Leaf implements Component { public void render(){ System.out.println("Leaf"); } }
class Composite implements Component {
    private List<Component> children = new ArrayList<>();
    public void add(Component c){ children.add(c); }
    public void render(){ System.out.println("Composite start"); children.forEach(Component::render); }
}
```

### 2.4 Decorator
```java
interface Coffee { double cost(); String desc(); }
class SimpleCoffee implements Coffee { public double cost(){ return 2; } public String desc(){ return "Simple"; } }
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decorated;
    CoffeeDecorator(Coffee c){ this.decorated = c; }
}
class Milk extends CoffeeDecorator { Milk(Coffee c){ super(c); } public double cost(){ return decorated.cost() + 0.5; } public String desc(){ return decorated.desc() + ", milk"; } }
```

### 2.5 Facade
```java
class CPU { void freeze(){} void jump(long pos){} void execute(){} }
class Memory { void load(long pos, byte[] data){} }
class HardDrive { byte[] read(long l, int size){ return new byte[size]; } }
class ComputerFacade {
    private CPU cpu = new CPU(); private Memory memory = new Memory(); private HardDrive hd = new HardDrive();
    public void start(){ cpu.freeze(); memory.load(0, hd.read(0, 1024)); cpu.jump(0); cpu.execute(); }
}
```

### 2.6 Flyweight
```java
import java.util.*;
class Glyph { private final char c; Glyph(char c){ this.c = c; } void draw(){ System.out.println(c); } }
class GlyphFactory {
    private Map<Character, Glyph> pool = new HashMap<>();
    Glyph getGlyph(char c){ return pool.computeIfAbsent(c, Glyph::new); }
}
```

### 2.7 Proxy
```java
interface Image { void display(); }
class RealImage implements Image {
    private String filename; RealImage(String f){ this.filename = f; loadFromDisk(); }
    private void loadFromDisk(){ System.out.println("Loading " + filename); }
    public void display(){ System.out.println("Displaying " + filename); }
}
class ProxyImage implements Image {
    private String filename; private RealImage real;
    ProxyImage(String f){ this.filename = f; }
    public void display(){ if(real==null) real = new RealImage(filename); real.display(); }
}
```

---

## 3. Behavioral Patterns

### 3.1 Chain of Responsibility
```java
abstract class Handler {
    protected Handler next;
    public void setNext(Handler h){ next = h; }
    abstract void handle(String req);
}
class AuthHandler extends Handler { void handle(String req){ if(req.equals("auth")) System.out.println("Auth done"); else if(next!=null) next.handle(req); } }
class LogHandler extends Handler { void handle(String req){ System.out.println("Log: " + req); if(next!=null) next.handle(req); } }
```

### 3.2 Command
```java
interface Command { void execute(); }
class Light { void on(){ System.out.println("Light ON"); } void off(){ System.out.println("Light OFF"); } }
class LightOnCommand implements Command { private Light light; LightOnCommand(Light l){ this.light=l; } public void execute(){ light.on(); } }
class Remote { private Command slot; void setCommand(Command c){ slot = c; } void press(){ slot.execute(); } }
```

### 3.3 Interpreter
```java
// Simple boolean expression interpreter: literals true/false and OR
interface Expression { boolean interpret(); }
class Literal implements Expression { private boolean val; Literal(boolean v){val=v;} public boolean interpret(){return val;} }
class OrExpression implements Expression { private Expression a,b; OrExpression(Expression a, Expression b){this.a=a;this.b=b;} public boolean interpret(){ return a.interpret() || b.interpret(); } }
```

### 3.4 Iterator
```java
import java.util.*;
class MyCollection {
    private List<String> items = new ArrayList<>();
    void add(String s){ items.add(s); }
    Iterator<String> iterator(){ return items.iterator(); }
}
```

### 3.5 Mediator
```java
import java.util.*;
abstract class Mediator { abstract void send(String msg, Colleague col); }
abstract class Colleague { protected Mediator mediator; Colleague(Mediator m){ this.mediator=m; } }
class ConcreteMediator extends Mediator {
    private List<Colleague> cols = new ArrayList<>();
    void add(Colleague c){ cols.add(c); }
    void send(String msg, Colleague origin){ cols.stream().filter(c->c!=origin).forEach(c-> System.out.println("Delivering: " + msg)); }
}
class ConcreteColleague extends Colleague { ConcreteColleague(Mediator m){ super(m); } void send(String msg){ mediator.send(msg, this); } }
```

### 3.6 Memento
```java
class Memento { private final String state; Memento(String s){ state = s; } String getState(){ return state; } }
class Originator { private String state; void set(String s){ state = s; } Memento save(){ return new Memento(state); } void restore(Memento m){ state = m.getState(); } }
class Caretaker { private List<Memento> history = new ArrayList<>(); void add(Memento m){ history.add(m); } Memento get(int i){ return history.get(i); } }
```

### 3.7 Observer
```java
import java.util.*;
interface Observer { void update(String msg); }
interface Subject { void attach(Observer o); void detach(Observer o); void notifyObservers(); }
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>(); private String state;
    public void attach(Observer o){ observers.add(o); }
    public void detach(Observer o){ observers.remove(o); }
    public void setState(String s){ state = s; notifyObservers(); }
    public void notifyObservers(){ observers.forEach(o->o.update(state)); }
}
class ConcreteObserver implements Observer { private String name; ConcreteObserver(String name){this.name=name;} public void update(String msg){ System.out.println(name+" got: " + msg); } }
```

### 3.8 State
```java
interface State { void handle(Context c); }
class Context { private State state; Context(State s){ state = s; } void setState(State s){ state = s; } void request(){ state.handle(this); } }
class ConcreteStateA implements State { public void handle(Context c){ System.out.println("State A -> switch to B"); c.setState(new ConcreteStateB()); } }
class ConcreteStateB implements State { public void handle(Context c){ System.out.println("State B -> switch to A"); c.setState(new ConcreteStateA()); } }
```

### 3.9 Strategy
```java
interface Strategy { int execute(int a, int b); }
class Add implements Strategy { public int execute(int a, int b){ return a+b; } }
class Multiply implements Strategy { public int execute(int a, int b){ return a*b; } }
class ContextStrategy { private Strategy strategy; ContextStrategy(Strategy s){ this.strategy = s; } int doOp(int a, int b){ return strategy.execute(a,b); } }
```

### 3.10 Template Method
```java
abstract class Game {
    final void play(){ initialize(); startPlay(); endPlay(); }
    abstract void initialize(); abstract void startPlay(); abstract void endPlay();
}
class Football extends Game { void initialize(){ System.out.println("Football init"); } void startPlay(){ System.out.println("Football start"); } void endPlay(){ System.out.println("Football end"); } }
```

### 3.11 Visitor
```java
interface Visitor { void visit(ConcreteElementA a); void visit(ConcreteElementB b); }
interface Element { void accept(Visitor v); }
class ConcreteElementA implements Element { void operationA(){} public void accept(Visitor v){ v.visit(this); } }
class ConcreteElementB implements Element { void operationB(){} public void accept(Visitor v){ v.visit(this); } }
class ConcreteVisitor implements Visitor { public void visit(ConcreteElementA a){ System.out.println("Visited A"); } public void visit(ConcreteElementB b){ System.out.println("Visited B"); } }
```

---


_**Tokhir ASADOV:** Foydali bo`ldi degan umiddaman._

